def load_pipeline(pipeline_string):
    """Load the pipeline from the candidate's solution (in accordance to the string generated by the GP grammar) for DAG evaluate representation.

    Parameters
    ----------

    pipeline : string
       A string contaning the method and the respective arguments.

    """
    # algorithms in the pipeline:
    algs = pipeline_string.strip().split()

    # Setting the choices of the algorithms and preprocessors:
    prep_choices = ['PCA', 'kBest']
    alg_choices = ['SVC', 'logR', 'Perceptron', 'SGD',
                   'PAC', 'LDA', 'QDA', 'MLP', 'gaussianNB', 'DT']

    # inehrent part of the translation:
    input_part = '{"input": [[], "input", ["IN:0"]], '

    i = 0
    class_part = ''
    prep_part = ''
    prep_in_out = '\"IN:0\"'

    while (i < len(algs)):
        if(algs[i] in prep_choices):
            prep_alg = load_preprocessing_alg(algs, i, prep_in_out)
            prep_part += prep_alg[0]
            i += prep_alg[1]
            prep_in_out = prep_alg[2]

        elif(algs[i] in alg_choices):
            if(i != 0):
                class_alg = load_classification_alg(algs, prep_in_out, i)
            else:
                class_alg = load_classification_alg(algs, '\"IN:0\"', i)
            class_part = class_alg[0]
            i += class_alg[1]
        else:
            print('Error during parsing!')
            break

    # Divide the translation into input, preprocessing and classification:
    output = input_part + prep_part + class_part

    return output


def load_preprocessing_alg(alg, i, prep_input):
    if(alg[i] == "PCA"):
        return PCA(alg, i, prep_input)
    elif(alg[i] == "kBest"):
        return kBest(alg, i, prep_input)


def PCA(alg, i, prep_input):
    prep_output = '\"PRE:' + str(i) + '\"'
    dag_output = '\"PCA\": [[' + prep_input + '], [\"PCA\", '
    dag_output += '{\"n_components\":' + alg[i + 1] + ', '
    dag_output += '\"whiten\":\"' + alg[i + 2] + '\", '
    dag_output += '\"svd_solver\":\"' + alg[i + 3] + '\", '
    dag_output += '\"tol\":' + alg[i + 4] + ', '
    dag_output += '\"iterated_power\":' + \
        alg[i + 5] + '}], [' + prep_output + ']], '
    return dag_output, 6, prep_output


def kBest(alg, i, prep_input):
    prep_output = '\"PRE:' + str(i) + '\"'
    dag_output = '\"kBest\": [[' + prep_input + '], [\"kBest\", '
    dag_output += '{\"k\":' + alg[i + 1] + '}], [' + prep_output + ']], '
    return dag_output, 2, prep_output


def load_classification_alg(alg, input_param, i):
    if(alg[i] == "MLP"):
        return mlp(alg, input_param, i)
    elif(alg[i] == "logR"):
        return log_reg(alg, input_param, i)
    elif(alg[i] == "DT"):
        return dt(alg, input_param, i)
    elif(alg[i] == "SVC"):
        return svc(alg, input_param, i)
    elif(alg[i] == "gaussianNB"):
        return gnb(alg, input_param, i)
    elif(alg[i] == "LDA"):
        return lda(alg, input_param, i)
    elif(alg[i] == "QDA"):
        return qda(alg, input_param, i)
    elif(alg[i] == "SGD"):
        return sgd(alg, input_param, i)
    elif(alg[i] == "Perceptron"):
        return perceptron(alg, input_param, i)
    elif(alg[i] == "PAC"):
        return pac(alg, input_param, i)
    else:
        return None


def mlp(alg, input_param, i):
    dag_output = '\"MLP\": [[' + input_param + '], [\"MLP\", '
    dag_output += '{\"learning_rate\":\"' + alg[i + 1] + '\", '
    dag_output += '\"learning_rate_init\":' + alg[i + 2] + ', '
    dag_output += '\"momentum\":' + alg[i + 3] + ', '
    dag_output += '\"max_iter\":' + alg[i + 4] + ', '
    dag_output += '\"activation\":\"' + alg[i + 5] + '\"}], []]}'

    return dag_output, 6


def log_reg(alg, input_param, i):
    dag_output = '\"logR\": [[' + input_param + '], [\"logR\", '
    dag_output += '{\"penalty\":\"' + alg[i + 1] + '\", '
    dag_output += '\"tol\":' + alg[i + 2] + ', '
    dag_output += '\"C\":' + alg[i + 3] + ', '
    dag_output += '\"fit_intercept\":\"' + alg[i + 4] + '\", '
    dag_output += '\"max_iter\":' + alg[i + 5] + ', '
    dag_output += '\"warm_start\":\"' + alg[i + 6] + '\"}], []]}'

    return dag_output, 7


def dt(alg, input_param, i):
    dag_output = '\"DT\": [[' + input_param + '], [\"DT\", '
    dag_output += '{\"criterion\":\"' + alg[i + 1] + '\", '
    dag_output += '\"splitter\":\"' + alg[i + 2] + '\", '
    dag_output += '\"max_depth\":' + alg[i + 3] + ', '
    dag_output += '\"presort\":\"' + alg[i + 4] + '\", '
    dag_output += '\"max_features\":\"' + alg[i + 5] + '\", '
    dag_output += '\"min_weight_fraction_leaf\":' + alg[i + 6] + ', '
    dag_output += '\"max_leaf_nodes\":' + alg[i + 7] + '}], []]}'

    return dag_output, 8


def svc(alg, input_param, i):
    dag_output = '\"SVC\": [[' + input_param + '], [\"SVC\", '
    dag_output += '{\"C\":' + alg[i + 1] + ', '
    dag_output += '\"kernel\":\"' + alg[i + 2] + '\", '
    dag_output += '\"gamma\":' + alg[i + 3] + ', '
    dag_output += '\"coef0\":' + alg[i + 4] + ', '
    dag_output += '\"degree\":' + alg[i + 5] + ', '
    dag_output += '\"tol\":' + alg[i + 6] + ', '
    dag_output += '\"max_iter\":' + alg[i + 7] + '}], []]}'

    return dag_output, 8


def gnb(alg, input_param, i):
    dag_output = '\"gaussianNB\": [[' + input_param + '], [\"gaussianNB\", '
    dag_output += '{}], []]}'

    return dag_output, 1


def lda(alg, input_param, i):
    dag_output = '\"LDA\": [[' + input_param + '], [\"LDA\", '
    dag_output += '{\"n_components\":' + alg[i + 1] + ', '
    dag_output += '\"tol\":' + alg[i + 2] + '}], []]}'

    return dag_output, 3


def qda(alg, input_param, i):
    dag_output = '\"QDA\": [[' + input_param + '], [\"QDA\", '
    dag_output += '{\"reg_param\":' + alg[i + 1] + ', '
    dag_output += '\"tol\":' + alg[i + 2] + '}], []]}'

    return dag_output, 3


def sgd(alg, input_param, i):
    dag_output = '\"SGD\": [[' + input_param + '], [\"SGD\", '
    dag_output += '{\"penalty\":\"' + alg[i + 1] + '\", '
    dag_output += '\"tol\":' + alg[i + 2] + ', '
    dag_output += '\"max_iter\":' + alg[i + 3] + ', '
    dag_output += '\"loss\":\"' + alg[i + 4] + '\", '
    dag_output += '\"warm_start\":\"' + alg[i + 5] + '\"}], []]}'

    return dag_output, 6


def perceptron(alg, input_param, i):
    dag_output = '\"Perceptron\": [[' + input_param + '], [\"Perceptron\", '
    dag_output += '{\"penalty\":\"' + alg[i + 1] + '\", '
    dag_output += '\"tol\":' + alg[i + 2] + ', '
    dag_output += '\"max_iter\":' + alg[i + 3] + ', '
    dag_output += '\"warm_start\":\"' + alg[i + 4] + '\"}], []]}'

    return dag_output, 5


def pac(alg, input_param, i):
    dag_output = '\"PAC\": [[' + input_param + '], [\"PAC\", '
    dag_output += '{\"tol\":' + alg[i + 1] + ', '
    dag_output += '\"C\":' + alg[i + 2] + ', '
    dag_output += '\"max_iter\":' + alg[i + 3] + ', '
    dag_output += '\"warm_start\":\"' + alg[i + 4] + '\"}], []]}'

    return dag_output, 5
